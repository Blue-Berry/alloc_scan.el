;;; alloc-scan.el --- OCaml allocation scanner for Emacs -*- lexical-binding: t; -*-

;; Copyright (C) 2024

;; Author: Liam Berry <liamandberry@gmail.com>
;; Keywords: ocaml, tools, languages
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))
;; URL: https://github.com/Blue-Berry/alloc-scan.el

;; This file is not part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; alloc-scan.el is an Emacs plugin that analyzes OCaml compiler output
;; to highlight memory allocation points in source code.  It parses
;; .cmx.dump files generated by the OCaml compiler and displays allocation
;; information as overlays in the buffer.
;;
;; Features:
;; - Highlights allocation points in OCaml source code with CMM decoding
;; - Shows allocation details (type, size, memory usage) as virtual text
;; - Minibuffer integration for selecting .cmx.dump files
;; - Customizable highlighting faces and styles
;; - Automatic refresh when dump files change (file watching or polling)
;; - Intelligent caching for improved performance
;; - Comprehensive statistics and memory analysis
;;
;; Usage:
;; M-x alloc-scan                   - Scan current buffer for allocations
;; M-x alloc-scan-file              - Select dump file and scan specific file
;; M-x alloc-scan-clear             - Clear all allocation highlights
;; M-x alloc-scan-show-statistics   - Show allocation analysis
;; M-x alloc-scan-toggle-auto-refresh - Toggle automatic refresh
;; M-x alloc-scan-cleanup-all       - Clean up all plugin data

;;; Code:

(require 'cl-lib)

;;; ============================================================================
;;; Customization and Configuration
;;; ============================================================================

(defgroup alloc-scan nil
  "OCaml allocation scanner."
  :group 'tools
  :prefix "alloc-scan-")

(defface alloc-scan-highlight-face
  '((t (:box (:line-width 1 :color "#cccccc" :style nil))))
  "Face used to highlight allocation points with a subtle outline."
  :group 'alloc-scan)

(defcustom alloc-scan-highlight-style 'box
  "Style of highlighting for allocation points.
- `box': Thin border around the allocation
- `underline': Underline the allocation
- `background': Light background color
- `bold': Make text bold
- `custom': Use the alloc-scan-highlight-face directly"
  :type '(choice (const :tag "Subtle box outline" box)
                 (const :tag "Underline" underline)
                 (const :tag "Light background" background)
                 (const :tag "Bold text" bold)
                 (const :tag "Custom face" custom))
  :group 'alloc-scan)

(defcustom alloc-scan-highlight-color "#cccccc"
  "Color used for allocation highlighting.
This applies to box borders, underlines, and backgrounds."
  :type 'color
  :group 'alloc-scan)

(defcustom alloc-scan-show-virtual-text t
  "Whether to show allocation details as virtual text."
  :type 'boolean
  :group 'alloc-scan)

(defcustom alloc-scan-virtual-text-face 'font-lock-comment-face
  "Face used for virtual text showing allocation details."
  :type 'face
  :group 'alloc-scan)

(defcustom alloc-scan-auto-refresh t
  "Whether to automatically refresh when dump files change."
  :type 'boolean
  :group 'alloc-scan)

(defcustom alloc-scan-polling-interval 2
  "Interval in seconds for polling dump files when file-notify is unavailable."
  :type 'number
  :group 'alloc-scan)

(defcustom alloc-scan-cache-size 10
  "Maximum number of dump files to cache."
  :type 'integer
  :group 'alloc-scan)

(defcustom alloc-scan-debug nil
  "Enable debug messages for allocation parsing."
  :type 'boolean
  :group 'alloc-scan)

;;; ============================================================================
;;; Internal Variables and State
;;; ============================================================================

(defvar alloc-scan--overlays nil
  "List of overlays created by alloc-scan.")
(make-variable-buffer-local 'alloc-scan--overlays)

(defvar alloc-scan--cache (make-hash-table :test 'equal)
  "Cache for parsed dump files. Key: (file-path . file-mtime), Value: allocations")

(defvar alloc-scan--cache-order nil
  "List tracking cache access order for LRU eviction.")

(defvar alloc-scan--file-watchers (make-hash-table :test 'equal)
  "Hash table tracking file watchers. Key: dump file path, Value: file-notify descriptor")

(defvar alloc-scan--watched-buffers (make-hash-table :test 'equal)
  "Hash table tracking which buffers are watching which dump files.")

(defvar alloc-scan--polling-timer nil
  "Timer for polling file changes when file-notify is unavailable.")

(defvar alloc-scan--file-mtimes (make-hash-table :test 'equal)
  "Hash table tracking file modification times for polling.")

;;; ============================================================================
;;; OCaml CMM Allocation Decoding
;;; ============================================================================

(defun alloc-scan--decode-allocation-number (alloc-number)
  "Decode CMM allocation number into size and tag components.
Based on the encoding: allocation_number = (size << 10) + tag
Returns (size-in-words . tag) or nil if invalid."
  (when (and alloc-number (numberp alloc-number) (>= alloc-number 0))
    (let ((size-words (ash alloc-number -10))  ; Right shift by 10 bits
          (tag (logand alloc-number 1023)))    ; Bottom 10 bits (mask 0x3FF)
      (cons size-words tag))))

(defun alloc-scan--allocation-type-name (tag)
  "Return human-readable name for allocation TAG."
  (cond
   ((= tag 0) "tuple/record")
   ((and (>= tag 1) (<= tag 245)) (format "variant-%d" tag))
   ((= tag 246) "lazy")
   ((= tag 247) "closure")
   ((= tag 248) "object")
   ((= tag 249) "infix")
   ((= tag 250) "forward")
   ((= tag 252) "string")
   ((= tag 253) "float")
   ((= tag 254) "float-array")
   ((= tag 255) "custom")
   (t (format "tag-%d" tag))))

(defun alloc-scan--allocation-memory-info (size-words)
  "Calculate memory usage information from SIZE-WORDS.
Returns (total-words . size-bytes) including header word.
All heap-allocated blocks have headers regardless of type."
  (let* ((word-size 8)  ; OCaml words are 8 bytes on 64-bit, 4 bytes on 32-bit
         (total-words (+ size-words 1))  ; All blocks have headers
         (size-bytes (* total-words word-size)))
    (cons total-words size-bytes)))

(defun alloc-scan--format-allocation-info (alloc-number)
  "Format allocation information for display.
Returns formatted string with decoded allocation details."
  (if-let* ((decoded (alloc-scan--decode-allocation-number alloc-number))
            (size-words (car decoded))
            (tag (cdr decoded))
            (type-name (alloc-scan--allocation-type-name tag))
            (memory-info (alloc-scan--allocation-memory-info size-words))
            (total-words (car memory-info))
            (size-bytes (cdr memory-info)))
      (format " [%s: %d words (%d bytes)]" 
              type-name size-words size-bytes)
    (format " [Raw: %s]" alloc-number)))

;;; ============================================================================
;;; Project Discovery and File Management
;;; ============================================================================

(defun alloc-scan--find-dune-project (filepath)
  "Find the dune-project file starting from FILEPATH.
Traverses up the directory tree until a dune-project file is found.
Returns the directory containing dune-project, or nil if not found."
  (when (and filepath (or (file-exists-p filepath) (file-directory-p filepath)))
    (let ((dir (file-name-directory (expand-file-name filepath))))
      (while (and dir
                  (not (file-exists-p (expand-file-name "dune-project" dir)))
                  (not (string= dir (file-name-directory (directory-file-name dir)))))
        (setq dir (file-name-directory (directory-file-name dir))))
      (when (and dir (file-exists-p (expand-file-name "dune-project" dir)))
        dir))))

(defun alloc-scan--find-build-files (project-root pattern)
  "Find files matching PATTERN in _build directories under PROJECT-ROOT.
Returns a list of absolute file paths, or empty list if none found."
  (when (and project-root (file-directory-p project-root))
    (let ((build-dir (expand-file-name "_build" project-root)))
      (when (file-directory-p build-dir)
        (condition-case err
            (directory-files-recursively build-dir pattern t)
          (error
           (when alloc-scan-debug
             (message "Error scanning build directory %s: %s" build-dir (error-message-string err)))
           nil))))))

(defun alloc-scan--select-dump-file ()
  "Select a .cmx.dump file using minibuffer completion."
  (let* ((current-file (or (buffer-file-name) default-directory))
         (project-root (alloc-scan--find-dune-project current-file))
         (dump-files (when project-root
                       (alloc-scan--find-build-files project-root "\\.cmx\\.dump$"))))
    
    (cond
     ;; No dump files found - prompt for manual selection
     ((null dump-files)
      (read-file-name "Select .cmx.dump file: " 
                      (or project-root default-directory)
                      nil t nil
                      (lambda (name) (string-suffix-p ".cmx.dump" name))))
     
     ;; Single dump file found - offer it as default
     ((= (length dump-files) 1)
      (let ((default-file (car dump-files)))
        (if (y-or-n-p (format "Use dump file: %s? " 
                              (file-name-nondirectory default-file)))
            default-file
          (read-file-name "Select .cmx.dump file: " 
                          (file-name-directory default-file)
                          default-file t nil
                          (lambda (name) (string-suffix-p ".cmx.dump" name))))))
     
     ;; Multiple dump files - use completing-read
     (t
      (let* ((file-alist (mapcar (lambda (file)
                                   (cons (concat (file-name-nondirectory file)
                                                 " (" (file-name-directory file) ")")
                                         file))
                                 dump-files))
             (choice (completing-read "Select dump file: " 
                                      file-alist nil t nil nil
                                      (caar file-alist))))
        (cdr (assoc choice file-alist)))))))

;;; ============================================================================
;;; Caching System
;;; ============================================================================

(defun alloc-scan--cache-key (file)
  "Generate cache key for FILE based on path and modification time."
  (when (and file (file-exists-p file))
    (cons file (file-attribute-modification-time (file-attributes file)))))

(defun alloc-scan--cache-get (file)
  "Get cached allocations for FILE, or nil if not cached or stale."
  (let ((key (alloc-scan--cache-key file)))
    (when key
      (let ((cached (gethash key alloc-scan--cache)))
        (when cached
          ;; Update access order for LRU
          (setq alloc-scan--cache-order 
                (cons key (delete key alloc-scan--cache-order)))
          (when alloc-scan-debug
            (message "Cache hit for %s" file))
          cached)))))

(defun alloc-scan--cache-put (file allocations)
  "Cache ALLOCATIONS for FILE."
  (let ((key (alloc-scan--cache-key file)))
    (when key
      ;; Evict oldest entries if cache is full
      (while (>= (hash-table-count alloc-scan--cache) alloc-scan-cache-size)
        (let ((oldest-key (car (last alloc-scan--cache-order))))
          (when oldest-key
            (remhash oldest-key alloc-scan--cache)
            (setq alloc-scan--cache-order (butlast alloc-scan--cache-order)))))
      
      ;; Add new entry
      (puthash key allocations alloc-scan--cache)
      (setq alloc-scan--cache-order 
            (cons key (delete key alloc-scan--cache-order)))
      (when alloc-scan-debug
        (message "Cached %d allocations for %s" (length allocations) file)))))

(defun alloc-scan--cache-clear ()
  "Clear the allocation cache."
  (interactive)
  (clrhash alloc-scan--cache)
  (setq alloc-scan--cache-order nil)
  (when alloc-scan-debug
    (message "Allocation cache cleared")))

;;; ============================================================================
;;; CMM Dump File Parsing
;;; ============================================================================

(defun alloc-scan--parse-allocation-match (regex content handler-fn)
  "Generic function to parse allocations using REGEX in CONTENT.
Calls HANDLER-FN for each match to extract allocation data.
Returns list of allocations."
  (condition-case err
      (let ((allocations nil)
            (start 0)
            (match-count 0)
            (max-iterations 10000))
        (while (and (string-match regex content start)
                    (< start (length content))
                    (< match-count max-iterations))
          (let ((match-start (match-beginning 0))
                (match-end-pos (match-end 0)))
            (setq match-count (1+ match-count))
            (when-let* ((allocation (funcall handler-fn content)))
              (push allocation allocations))
            ;; Ensure we make progress
            (if (> match-end-pos start)
                (setq start match-end-pos)
              (setq start (1+ start)))))
        (when (>= match-count max-iterations)
          (message "WARNING: Hit maximum iteration limit (%d), stopping parse" max-iterations))
        (nreverse allocations))
    (error
     (message "Error parsing allocations: %s" (error-message-string err))
     nil)))

(defun alloc-scan--parse-curly-brace-allocation (content)
  "Parse a single curly brace allocation from CONTENT at current match.
Returns (filepath line col-start col-end blocks) or nil."
  (let ((locations-str (match-string 1 content))
        (blocks-str (match-string 2 content)))
    (when (and blocks-str (string-match "^[0-9]+$" blocks-str))
      (let ((blocks (string-to-number blocks-str)))
        (when alloc-scan-debug
          (message "Found allocation: locations='%s' blocks=%d" locations-str blocks))
        ;; Parse first location: filepath:line,col_start-col_end
        (when (string-match "\\([^:;]+\\):\\([0-9]+\\),\\([0-9]+\\)-\\([0-9]+\\)" locations-str)
          (let ((filepath (match-string 1 locations-str))
                (line-str (match-string 2 locations-str))
                (col-start-str (match-string 3 locations-str))
                (col-end-str (match-string 4 locations-str)))
            (when (and line-str col-start-str col-end-str
                       (string-match "^[0-9]+$" line-str)
                       (string-match "^[0-9]+$" col-start-str)
                       (string-match "^[0-9]+$" col-end-str))
              (let ((line-num (string-to-number line-str))
                    (col-start (string-to-number col-start-str))
                    (col-end (string-to-number col-end-str)))
                (when (and (> line-num 0) (>= col-end col-start) (>= col-start 0))
                  (list filepath line-num col-start col-end blocks))))))))))

(defun alloc-scan--parse-description-allocation (content)
  "Parse a single description allocation from CONTENT at current match.
Returns (filepath line col-start col-end blocks) or nil."
  (let ((blocks-str (match-string 1 content))
        (description (match-string 2 content)))
    (when (and blocks-str (string-match "^[0-9]+$" blocks-str))
      (let ((blocks (string-to-number blocks-str)))
        (when alloc-scan-debug
          (message "Found description allocation: desc='%s' blocks=%d" description blocks))
        ;; Extract location info from description: [file.ml:line,col--col]
        (when (string-match "\\[\\([^:]+\\):\\([0-9]+\\),\\([0-9]+\\)--\\([0-9]+\\)\\]" description)
          (let ((filepath (match-string 1 description))
                (line-str (match-string 2 description))
                (col-start-str (match-string 3 description))
                (col-end-str (match-string 4 description)))
            (when (and line-str col-start-str col-end-str
                       (string-match "^[0-9]+$" line-str)
                       (string-match "^[0-9]+$" col-start-str)
                       (string-match "^[0-9]+$" col-end-str))
              (let ((line-num (string-to-number line-str))
                    (col-start (string-to-number col-start-str))
                    (col-end (string-to-number col-end-str)))
                (when (and (> line-num 0) (>= col-end col-start) (>= col-start 0))
                  (list filepath line-num col-start col-end blocks))))))))))

(defun alloc-scan--parse-curly-brace-allocations (content)
  "Parse curly brace format allocations from CONTENT."
  (alloc-scan--parse-allocation-match
   "(alloc{\\([^}]+\\)}[ \t\n]*\\([0-9]+\\)"
   content
   #'alloc-scan--parse-curly-brace-allocation))

(defun alloc-scan--parse-description-allocations (content)
  "Parse description format allocations from CONTENT."
  (alloc-scan--parse-allocation-match
   "(alloc[ \t\n]+\\([0-9]+\\)[ \t\n]+\"\\([^\"]+\\)"
   content
   #'alloc-scan--parse-description-allocation))

(defun alloc-scan--parse-dump-file (file)
  "Parse allocation information from dump FILE.
Returns list of (filepath line col-start col-end blocks).
Uses caching to avoid re-parsing unchanged files."
  (when (and file (file-readable-p file))
    ;; Try cache first
    (or (alloc-scan--cache-get file)
        ;; Cache miss - parse and cache result
        (let ((allocations
               (with-temp-buffer
                 (insert-file-contents file)
                 (let ((content (buffer-string)))
                   (when alloc-scan-debug
                     (message "Parsing file: %s (%d chars)" file (length content)))
                   ;; Parse both formats and combine results
                   (let ((curly-allocations (alloc-scan--parse-curly-brace-allocations content))
                         (desc-allocations (alloc-scan--parse-description-allocations content)))
                     (let ((total-allocations (append curly-allocations desc-allocations)))
                       (when alloc-scan-debug
                         (message "Total allocations found: %d (curly: %d, description: %d)" 
                                  (length total-allocations)
                                  (length curly-allocations)
                                  (length desc-allocations)))
                       total-allocations))))))
          ;; Cache the result
          (alloc-scan--cache-put file allocations)
          allocations))))

;;; ============================================================================
;;; Overlay Management and Highlighting
;;; ============================================================================

(defun alloc-scan--get-highlight-face ()
  "Get the face to use for highlighting based on user preferences."
  (pcase alloc-scan-highlight-style
    ('box `(:box (:line-width 1 :color ,alloc-scan-highlight-color :style nil)))
    ('underline `(:underline (:color ,alloc-scan-highlight-color :style line)))
    ('background `(:background ,alloc-scan-highlight-color))
    ('bold `(:weight bold :foreground ,alloc-scan-highlight-color))
    ('custom 'alloc-scan-highlight-face)
    (_ 'alloc-scan-highlight-face)))

(defun alloc-scan--calculate-positions (line col-start col-end)
  "Calculate buffer positions for LINE, COL-START, and COL-END.
Returns cons (START-POS . END-POS) or nil if invalid."
  (save-excursion
    (goto-char (point-min))
    (when (= (forward-line (1- line)) 0)
      (let* ((line-start (point))
             (line-end (line-end-position))
             (line-length (- line-end line-start)))
        (when (and (>= col-end col-start)
                   (<= col-start line-length))
          (let ((start-pos (+ line-start col-start))
                (end-pos (min (+ line-start col-end) line-end)))
            (cons start-pos end-pos)))))))

(defun alloc-scan--create-overlay (line col-start col-end blocks)
  "Create an overlay for allocation at LINE from COL-START to COL-END with BLOCKS.
Returns the created overlay, or nil if positions are invalid."
  (when-let* ((positions (alloc-scan--calculate-positions line col-start col-end)))
    (let ((overlay (make-overlay (car positions) (cdr positions))))
      (alloc-scan--configure-overlay overlay blocks)
      (push overlay alloc-scan--overlays)
      overlay)))

(defun alloc-scan--configure-overlay (overlay blocks)
  "Configure OVERLAY with face and virtual text for BLOCKS."
  (overlay-put overlay 'face (alloc-scan--get-highlight-face))
  (overlay-put overlay 'alloc-scan t)
  
  (when alloc-scan-show-virtual-text
    (let ((text (alloc-scan--format-allocation-info blocks)))
      (overlay-put overlay 'after-string
                   (propertize text 'face alloc-scan-virtual-text-face)))))

(defun alloc-scan--clear-overlays ()
  "Remove all allocation overlays in the current buffer."
  (dolist (overlay alloc-scan--overlays)
    (delete-overlay overlay))
  (setq alloc-scan--overlays nil))

(defun alloc-scan--filter-allocations-for-file (allocations current-file)
  "Filter ALLOCATIONS to only those relevant to CURRENT-FILE.
Matches based on file path suffix or basename."
  (cl-remove-if-not
   (lambda (alloc)
     (let ((filepath (car alloc)))
       (or (string-suffix-p filepath current-file)
           (string-suffix-p (file-name-nondirectory filepath)
                            (file-name-nondirectory current-file)))))
   allocations))

(defun alloc-scan--highlight-allocations (allocations &optional dump-file)
  "Highlight ALLOCATIONS in the current buffer.
Filters allocations to only those relevant to the current file.
If DUMP-FILE is provided, start watching it for changes."
  (alloc-scan--clear-overlays)
  (when-let* ((current-file (buffer-file-name)))
    (let ((relevant-allocations (alloc-scan--filter-allocations-for-file 
                                allocations current-file)))
      (dolist (alloc relevant-allocations)
        (cl-destructuring-bind (filepath line col-start col-end blocks) alloc
          (alloc-scan--create-overlay line col-start col-end blocks)))
      ;; Set up automatic cleanup and file watching
      (alloc-scan--setup-buffer-management dump-file))))

;;; ============================================================================
;;; Buffer Management and Cleanup
;;; ============================================================================

(defun alloc-scan--setup-buffer-management (&optional dump-file)
  "Set up buffer management hooks and file watching."
  (alloc-scan--setup-buffer-hooks)
  (when dump-file
    (alloc-scan--start-watching-file dump-file (current-buffer))))

(defun alloc-scan--setup-buffer-hooks ()
  "Set up hooks for automatic cleanup."
  (add-hook 'kill-buffer-hook #'alloc-scan--buffer-cleanup nil t)
  (add-hook 'change-major-mode-hook #'alloc-scan--buffer-cleanup nil t))

(defun alloc-scan--buffer-cleanup ()
  "Clean up alloc-scan overlays when buffer is killed or changed."
  (when (bound-and-true-p alloc-scan--overlays)
    (alloc-scan--clear-overlays))
  (alloc-scan--stop-watching-buffer (current-buffer)))

(defun alloc-scan--global-cleanup ()
  "Clean up alloc-scan data from all buffers."
  (dolist (buffer (buffer-list))
    (when (buffer-live-p buffer)
      (with-current-buffer buffer
        (when (bound-and-true-p alloc-scan--overlays)
          (alloc-scan--clear-overlays)))))
  ;; Stop all file watchers and polling
  (maphash (lambda (file _) (alloc-scan--stop-watching-file file)) alloc-scan--file-watchers)
  (clrhash alloc-scan--watched-buffers)
  (alloc-scan--stop-polling-timer)
  (clrhash alloc-scan--file-mtimes))

;;; ============================================================================
;;; File Watching and Auto-refresh
;;; ============================================================================

(defun alloc-scan--file-changed-callback (event)
  "Handle file change EVENT for watched dump files."
  (let ((file (nth 2 event))
        (change-type (nth 1 event)))
    (when alloc-scan-debug
      (message "File change detected: %s (%s)" file change-type))
    
    (when (and alloc-scan-auto-refresh
               (member change-type '(created changed)))
      ;; Invalidate cache for this file
      (alloc-scan--invalidate-cache-for-file file)
      ;; Refresh all buffers watching this file
      (alloc-scan--refresh-watching-buffers file))))

(defun alloc-scan--invalidate-cache-for-file (file)
  "Invalidate cache entries for FILE."
  (let ((keys-to-remove nil))
    (maphash (lambda (key _)
               (when (and (consp key) (string= (car key) file))
                 (push key keys-to-remove)))
             alloc-scan--cache)
    (dolist (key keys-to-remove)
      (remhash key alloc-scan--cache)
      (setq alloc-scan--cache-order (delete key alloc-scan--cache-order)))))

(defun alloc-scan--refresh-watching-buffers (file)
  "Refresh all buffers watching FILE."
  (maphash (lambda (buffer watched-file)
             (when (and (string= watched-file file)
                        (buffer-live-p buffer))
               (with-current-buffer buffer
                 (when (and (bound-and-true-p alloc-scan--overlays)
                            alloc-scan--overlays)
                   (when alloc-scan-debug
                     (message "Auto-refreshing buffer %s" (buffer-name)))
                   (let ((allocations (alloc-scan--parse-dump-file file)))
                     (when allocations
                       (alloc-scan--highlight-allocations allocations file)
                       (message "Auto-refreshed %d allocations from %s" 
                               (length allocations) 
                               (file-name-nondirectory file))))))))
           alloc-scan--watched-buffers))

(defun alloc-scan--start-watching-file (file buffer)
  "Start watching FILE for changes, associating it with BUFFER."
  (when (file-exists-p file)
    ;; Try file-notify first if available
    (if (and (fboundp 'file-notify-add-watch)
             (not (gethash file alloc-scan--file-watchers)))
        (condition-case err
            (let ((descriptor (file-notify-add-watch 
                              file
                              '(change)
                              #'alloc-scan--file-changed-callback)))
              (puthash file descriptor alloc-scan--file-watchers)
              (when alloc-scan-debug
                (message "Started file-notify watching: %s" file)))
          (error
           (when alloc-scan-debug
             (message "File-notify failed for %s: %s" file (error-message-string err)))
           (alloc-scan--start-polling-timer)))
      (progn
        (when alloc-scan-debug
          (message "Using polling for file watching: %s" file))
        (alloc-scan--start-polling-timer)))
    
    ;; Store initial modification time and associate buffer
    (let ((mtime (file-attribute-modification-time (file-attributes file))))
      (when mtime
        (puthash file mtime alloc-scan--file-mtimes)))
    (puthash buffer file alloc-scan--watched-buffers)))

(defun alloc-scan--stop-watching-file (file)
  "Stop watching FILE for changes."
  (when-let* ((descriptor (gethash file alloc-scan--file-watchers)))
    (condition-case err
        (when (fboundp 'file-notify-rm-watch)
          (file-notify-rm-watch descriptor)
          (remhash file alloc-scan--file-watchers)
          (when alloc-scan-debug
            (message "Stopped watching file: %s" file)))
      (error
       (when alloc-scan-debug
         (message "Failed to stop watching file %s: %s" file (error-message-string err)))))))

(defun alloc-scan--stop-watching-buffer (buffer)
  "Stop watching files for BUFFER."
  (when-let* ((watched-file (gethash buffer alloc-scan--watched-buffers)))
    (remhash buffer alloc-scan--watched-buffers)
    (alloc-scan--cleanup-file-watchers)))

(defun alloc-scan--cleanup-file-watchers ()
  "Clean up file watchers for dead buffers."
  (let ((buffers-to-remove nil))
    ;; Find dead buffers
    (maphash (lambda (buffer _)
               (unless (buffer-live-p buffer)
                 (push buffer buffers-to-remove)))
             alloc-scan--watched-buffers)
    
    ;; Remove dead buffer associations
    (dolist (buffer buffers-to-remove)
      (remhash buffer alloc-scan--watched-buffers))
    
    ;; Stop watching files that no longer have live buffers
    (let ((files-to-stop-watching nil))
      (maphash (lambda (file _)
                 (let ((has-live-buffer nil))
                   (maphash (lambda (buffer watched-file)
                              (when (and (string= watched-file file)
                                        (buffer-live-p buffer))
                                (setq has-live-buffer t)))
                            alloc-scan--watched-buffers)
                   (unless has-live-buffer
                     (push file files-to-stop-watching))))
               alloc-scan--file-watchers)
      
      (dolist (file files-to-stop-watching)
        (alloc-scan--stop-watching-file file)))
    
    ;; Stop polling if no files are being watched
    (when (= (hash-table-count alloc-scan--watched-buffers) 0)
      (alloc-scan--stop-polling-timer))))

(defun alloc-scan--polling-check-files ()
  "Check all watched files for changes (polling mode)."
  (when alloc-scan-auto-refresh
    (let ((files-to-check (make-hash-table :test 'equal)))
      ;; Collect unique files being watched
      (maphash (lambda (buffer file)
                 (when (buffer-live-p buffer)
                   (puthash file t files-to-check)))
               alloc-scan--watched-buffers)
      
      ;; Check each file for changes
      (maphash (lambda (file _)
                 (when (file-exists-p file)
                   (let* ((current-mtime (file-attribute-modification-time (file-attributes file)))
                          (stored-mtime (gethash file alloc-scan--file-mtimes)))
                     (when (and current-mtime
                                (or (not stored-mtime)
                                    (time-less-p stored-mtime current-mtime)))
                       (puthash file current-mtime alloc-scan--file-mtimes)
                       (when stored-mtime ; Don't trigger on first check
                         (alloc-scan--file-changed-callback `(nil changed ,file)))))))
               files-to-check))))

(defun alloc-scan--start-polling-timer ()
  "Start the polling timer if needed."
  (unless alloc-scan--polling-timer
    (setq alloc-scan--polling-timer
          (run-at-time alloc-scan-polling-interval 
                       alloc-scan-polling-interval 
                       #'alloc-scan--polling-check-files))
    (when alloc-scan-debug
      (message "Started polling timer (interval: %s seconds)" alloc-scan-polling-interval))))

(defun alloc-scan--stop-polling-timer ()
  "Stop the polling timer."
  (when alloc-scan--polling-timer
    (cancel-timer alloc-scan--polling-timer)
    (setq alloc-scan--polling-timer nil)
    (when alloc-scan-debug
      (message "Stopped polling timer"))))

;;; ============================================================================
;;; Statistics and Analysis
;;; ============================================================================

(defun alloc-scan--analyze-allocations (allocations)
  "Analyze ALLOCATIONS and return summary statistics using decoded CMM data."
  (when allocations
    (let ((total-count (length allocations))
          (total-words 0)
          (total-bytes 0)
          (files-map (make-hash-table :test 'equal))
          (type-buckets (make-hash-table :test 'equal))
          (size-buckets '((small . 0) (medium . 0) (large . 0) (huge . 0))))
      
      ;; Process each allocation
      (dolist (alloc allocations)
        (let* ((filepath (nth 0 alloc))
               (alloc-number (nth 4 alloc))
               (decoded (alloc-scan--decode-allocation-number alloc-number)))
          
          (when decoded
            (let* ((size-words (car decoded))
                   (tag (cdr decoded))
                   (type-name (alloc-scan--allocation-type-name tag))
                   (memory-info (alloc-scan--allocation-memory-info size-words))
                   (size-bytes (cdr memory-info)))
              
              ;; Accumulate statistics
              (setq total-words (+ total-words size-words))
              (setq total-bytes (+ total-bytes size-bytes))
              
              ;; Count per file
              (let ((file-count (gethash filepath files-map 0)))
                (puthash filepath (1+ file-count) files-map))
              
              ;; Count by allocation type
              (let ((type-count (gethash type-name type-buckets 0)))
                (puthash type-name (1+ type-count) type-buckets))
              
              ;; Categorize by size (in words)
              (cond 
               ((< size-words 2) (cl-incf (alist-get 'small size-buckets)))
               ((< size-words 8) (cl-incf (alist-get 'medium size-buckets)))
               ((< size-words 32) (cl-incf (alist-get 'large size-buckets)))
               (t (cl-incf (alist-get 'huge size-buckets))))))))
      
      ;; Convert hash tables to sorted lists
      (let ((files-list nil)
            (types-list nil))
        (maphash (lambda (file count) (push (cons file count) files-list)) files-map)
        (maphash (lambda (type count) (push (cons type count) types-list)) type-buckets)
        (setq files-list (sort files-list (lambda (a b) (> (cdr a) (cdr b)))))
        (setq types-list (sort types-list (lambda (a b) (> (cdr a) (cdr b)))))
        
        ;; Return comprehensive analysis
        `((total-allocations . ,total-count)
          (total-words . ,total-words)
          (total-bytes . ,total-bytes)
          (average-words . ,(if (> total-count 0) (/ total-words total-count) 0))
          (files-with-allocations . ,(hash-table-count files-map))
          (top-files . ,(seq-take files-list 5))
          (allocation-types . ,(seq-take types-list 10))
          (size-distribution . ,size-buckets))))))

(defun alloc-scan--format-statistics (stats)
  "Format STATS for display using decoded CMM allocation information."
  (when stats
    (let ((total-allocs (alist-get 'total-allocations stats))
          (total-words (alist-get 'total-words stats))
          (total-bytes (alist-get 'total-bytes stats))
          (avg-words (alist-get 'average-words stats))
          (file-count (alist-get 'files-with-allocations stats))
          (top-files (alist-get 'top-files stats))
          (alloc-types (alist-get 'allocation-types stats))
          (size-dist (alist-get 'size-distribution stats)))
      
      (concat 
       (format "=== Allocation Summary ===\n")
       (format "Total allocations: %d\n" total-allocs)
       (format "Total memory: %d words (%.2f KB)\n" total-words (/ total-bytes 1024.0))
       (format "Average size: %.1f words per allocation\n" avg-words)
       (format "Files with allocations: %d\n\n" file-count)
       
       (format "=== Allocation Types ===\n")
       (if alloc-types
           (mapconcat (lambda (entry)
                        (format "%-15s: %d allocations"
                                (car entry) (cdr entry)))
                      alloc-types "\n")
         "No type information available")
       "\n\n"
       
       (format "=== Size Distribution ===\n")
       (format "Small (< 2 words):   %d allocations\n" (alist-get 'small size-dist))
       (format "Medium (2-8 words):  %d allocations\n" (alist-get 'medium size-dist))
       (format "Large (8-32 words):  %d allocations\n" (alist-get 'large size-dist))
       (format "Huge (> 32 words):   %d allocations\n\n" (alist-get 'huge size-dist))
       
       (when top-files
         (concat
          (format "=== Top Files by Allocation Count ===\n")
          (mapconcat (lambda (entry)
                       (format "%s: %d allocations" 
                               (file-name-nondirectory (car entry))
                               (cdr entry)))
                     top-files "\n")))))))

;;; ============================================================================
;;; Interactive Commands
;;; ============================================================================

;;;###autoload
(defun alloc-scan ()
  "Scan current buffer for allocations using minibuffer to select dump file."
  (interactive)
  (let ((dump-file (alloc-scan--select-dump-file)))
    (when dump-file
      (let ((allocations (alloc-scan--parse-dump-file dump-file)))
        (if allocations
            (progn
              (alloc-scan--highlight-allocations allocations dump-file)
              (message "Found %d allocations" (length allocations)))
          (message "No allocations found in %s" dump-file))))))

;;;###autoload
(defun alloc-scan-file (file)
  "Scan FILE for allocations using minibuffer to select dump file."
  (interactive "fFile to scan: ")
  (let ((dump-file (alloc-scan--select-dump-file)))
    (when dump-file
      (with-current-buffer (find-file-noselect file)
        (let ((allocations (alloc-scan--parse-dump-file dump-file)))
          (if allocations
              (progn
                (alloc-scan--highlight-allocations allocations dump-file)
                (switch-to-buffer (current-buffer))
                (message "Found %d allocations" (length allocations)))
            (message "No allocations found in %s" dump-file)))))))

;;;###autoload
(defun alloc-scan-clear ()
  "Clear all allocation highlights in the current buffer."
  (interactive)
  (alloc-scan--clear-overlays)
  (message "Cleared allocation highlights"))

;;;###autoload
(defun alloc-scan-show-statistics ()
  "Show allocation statistics for a selected dump file."
  (interactive)
  (if-let* ((dump-file (completing-read 
                       "Select dump file for statistics: "
                       (let ((files nil))
                         (maphash (lambda (key _) 
                                   (when (stringp (car key))
                                     (push (car key) files))) 
                                 alloc-scan--cache)
                         files)))
            (allocations (alloc-scan--parse-dump-file dump-file)))
      (let ((stats (alloc-scan--analyze-allocations allocations)))
        (with-current-buffer (get-buffer-create "*Alloc-Scan Statistics*")
          (erase-buffer)
          (insert (alloc-scan--format-statistics stats))
          (goto-char (point-min))
          (read-only-mode 1)
          (display-buffer (current-buffer))))
    (message "No allocation data available. Run alloc-scan first.")))

;;;###autoload
(defun alloc-scan-toggle-auto-refresh ()
  "Toggle automatic refresh when dump files change."
  (interactive)
  (setq alloc-scan-auto-refresh (not alloc-scan-auto-refresh))
  (if alloc-scan-auto-refresh
      (alloc-scan--start-polling-timer)
    (alloc-scan--stop-polling-timer))
  (message "Auto-refresh %s" (if alloc-scan-auto-refresh "enabled" "disabled")))

;;;###autoload
(defun alloc-scan-cleanup-all ()
  "Clean up all alloc-scan overlays and cache."
  (interactive)
  (alloc-scan--global-cleanup)
  (alloc-scan--cache-clear)
  (message "Cleaned up all alloc-scan data"))

(provide 'alloc-scan)

;;; alloc-scan.el ends here
;;; alloc-scan.el --- OCaml allocation scanner for Emacs -*- lexical-binding: t; -*-

;; Copyright (C) 2024

;; Author: Liam Berry <liamandberry@gmail.com>
;; Keywords: ocaml, tools, languages
;; Version: 0.1.0
;; Package-Requires: ((emacs "28.1"))
;; URL: https://github.com/Blue-Berry/alloc-scan.el

;; This file is not part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; alloc-scan.el is an Emacs plugin that analyzes OCaml compiler output
;; to highlight memory allocation points in source code.  It parses
;; .cmx.dump files generated by the OCaml compiler and displays allocation
;; information as overlays in the buffer.
;;
;; Features:
;; - Highlights allocation points in OCaml source code
;; - Shows allocation details (block count, tag) as virtual text
;; - Dired integration for selecting .cmx.dump files
;; - Customizable highlighting faces
;;
;; Usage:
;; M-x alloc-scan       - Scan current buffer for allocations
;; M-x alloc-scan-file  - Select dump file and scan specific file
;; M-x alloc-scan-clear - Clear all allocation highlights

;;; Code:

(require 'dired)
(require 'cl-lib)

;;; Customization

(defgroup alloc-scan nil
  "OCaml allocation scanner."
  :group 'tools
  :prefix "alloc-scan-")

(defface alloc-scan-highlight-face
  '((t (:box (:line-width 1 :color "#cccccc" :style nil))))
  "Face used to highlight allocation points with a subtle outline."
  :group 'alloc-scan)

(defcustom alloc-scan-show-virtual-text t
  "Whether to show allocation details as virtual text."
  :type 'boolean
  :group 'alloc-scan)

(defcustom alloc-scan-virtual-text-face 'font-lock-comment-face
  "Face used for virtual text showing allocation details."
  :type 'face
  :group 'alloc-scan)

(defcustom alloc-scan-debug nil
  "Enable debug messages for allocation parsing."
  :type 'boolean
  :group 'alloc-scan)

;;; Internal variables

(defvar alloc-scan--overlays nil
  "List of overlays created by alloc-scan.")

(make-variable-buffer-local 'alloc-scan--overlays)

;;; Utility functions

(defun alloc-scan--find-dune-project (filepath)
  "Find the dune-project file starting from FILEPATH.
Goes up the directory tree until a dune-project file is found."
  (let ((dir (file-name-directory (expand-file-name filepath))))
    (while (and dir
                (not (file-exists-p (expand-file-name "dune-project" dir)))
                (not (string= dir (file-name-directory (directory-file-name dir)))))
      (setq dir (file-name-directory (directory-file-name dir))))
    (when (and dir (file-exists-p (expand-file-name "dune-project" dir)))
      dir)))

(defun alloc-scan--find-build-files (project-root pattern)
  "Find files matching PATTERN in _build directories under PROJECT-ROOT."
  (let ((build-dir (expand-file-name "_build" project-root))
        files)
    (when (file-directory-p build-dir)
      (setq files (directory-files-recursively build-dir pattern t)))
    files))

(defun alloc-scan--parse-dump-file (file)
  "Parse allocation information from dump FILE."
  (when (file-readable-p file)
    (with-temp-buffer
      (insert-file-contents file)
      (let ((content (buffer-string))
            allocations)
        ;; Find all allocation patterns with regex that handles whitespace
        (let ((start 0)
              (match-count 0)
              (last-start -1))
          (while (and (string-match "(alloc{\\([^}]+\\)} \\([0-9]+\\)" content start)
                      (< start (length content))
                      (not (= start last-start))) ; Prevent infinite loops
            (setq last-start start)
            (setq match-count (1+ match-count))
            (let ((locations-str (match-string 1 content))
                  (blocks (string-to-number (match-string 2 content)))
                  (match-start (match-beginning 0))
                  (match-end-pos (match-end 0)))
              (when alloc-scan-debug
                (message "Found allocation %d at pos %d-%d: locations='%s' blocks=%d" 
                         match-count match-start match-end-pos locations-str blocks))
              ;; Parse locations: filepath:line,col_start-col_end;...
              (dolist (loc-str (split-string locations-str ";"))
                (when (string-match "\\([^:]+\\):\\([0-9]+\\),\\([0-9]+\\)-\\([0-9]+\\)" loc-str)
                  (let ((filepath (match-string 1 loc-str))
                        (line-num (string-to-number (match-string 2 loc-str)))
                        (col-start (string-to-number (match-string 3 loc-str)))
                        (col-end (string-to-number (match-string 4 loc-str))))
                    (when alloc-scan-debug
                      (message "  -> %s:%d,%d-%d (%d blocks)" 
                               filepath line-num col-start col-end blocks))
                    (push (list filepath line-num col-start col-end blocks) allocations))))
              (setq start match-end-pos)
              ;; Safety check: if we're not advancing, break
              (when (and (> match-count 1000)
                         (= start last-start))
                (message "WARNING: Infinite loop detected, breaking")
                (setq start (length content)))))
          (when alloc-scan-debug
            (message "Total allocations found: %d" (length allocations))))
        (nreverse allocations)))))

;;; Highlighting functions

(defun alloc-scan--create-overlay (line col-start col-end blocks)
  "Create an overlay for allocation at LINE from COL-START to COL-END with BLOCKS."
  (save-excursion
    (goto-char (point-min))
    (forward-line (1- line))
    (let ((line-start (point))
          (line-end (line-end-position)))
      (when (and (>= col-end col-start)
                 (<= col-start (- line-end line-start)))
        (let* ((start-pos (+ line-start col-start))
               (end-pos (min (+ line-start col-end) line-end))
               (overlay (make-overlay start-pos end-pos)))
          (overlay-put overlay 'face 'alloc-scan-highlight-face)
          (when alloc-scan-show-virtual-text
            (let ((num-blocks (/ blocks 1024))
                  (tag (% blocks 1024)))
              (overlay-put overlay 'after-string
                           (propertize (format " [Blocks: %d; Tag: %d]" num-blocks tag)
                                       'face alloc-scan-virtual-text-face))))
          (overlay-put overlay 'alloc-scan t)
          (push overlay alloc-scan--overlays)
          overlay)))))

(defun alloc-scan--clear-overlays ()
  "Clear all allocation overlays in the current buffer."
  (dolist (overlay alloc-scan--overlays)
    (delete-overlay overlay))
  (setq alloc-scan--overlays nil))

(defun alloc-scan--highlight-allocations (allocations)
  "Highlight ALLOCATIONS in the current buffer."
  (alloc-scan--clear-overlays)
  (let ((current-file (buffer-file-name)))
    (when current-file
      (dolist (alloc allocations)
        (cl-destructuring-bind (filepath line col-start col-end blocks) alloc
          ;; Check if this allocation is for the current file
          (when (or (string-suffix-p filepath current-file)
                    (string-suffix-p (file-name-nondirectory filepath)
                                     (file-name-nondirectory current-file)))
            (alloc-scan--create-overlay line col-start col-end blocks)))))))

;;; File selection

(defun alloc-scan--select-dump-file ()
  "Select a .cmx.dump file using minibuffer completion."
  (let* ((current-file (or (buffer-file-name) default-directory))
         (project-root (alloc-scan--find-dune-project current-file))
         (dump-files (when project-root
                       (alloc-scan--find-build-files project-root "\\.cmx\\.dump$"))))
    
    (cond
     ;; No dump files found - prompt for manual selection
     ((null dump-files)
      (read-file-name "Select .cmx.dump file: " 
                      (or project-root default-directory)
                      nil t nil
                      (lambda (name) (string-suffix-p ".cmx.dump" name))))
     
     ;; Single dump file found - offer it as default
     ((= (length dump-files) 1)
      (let ((default-file (car dump-files)))
        (if (y-or-n-p (format "Use dump file: %s? " 
                              (file-name-nondirectory default-file)))
            default-file
          (read-file-name "Select .cmx.dump file: " 
                          (file-name-directory default-file)
                          default-file t nil
                          (lambda (name) (string-suffix-p ".cmx.dump" name))))))
     
     ;; Multiple dump files - use completing-read
     (t
      (let* ((file-alist (mapcar (lambda (file)
                                   (cons (concat (file-name-nondirectory file)
                                                 " (" (file-name-directory file) ")")
                                         file))
                                 dump-files))
             (choice (completing-read "Select dump file: " 
                                      file-alist nil t nil nil
                                      (caar file-alist))))
        (cdr (assoc choice file-alist)))))))

;;; Interactive commands

;;;###autoload
(defun alloc-scan ()
  "Scan current buffer for allocations using minibuffer to select dump file."
  (interactive)
  (let ((dump-file (alloc-scan--select-dump-file)))
    (when dump-file
      (let ((allocations (alloc-scan--parse-dump-file dump-file)))
        (if allocations
            (progn
              (alloc-scan--highlight-allocations allocations)
              (message "Found %d allocations" (length allocations)))
          (message "No allocations found in %s" dump-file))))))

;;;###autoload
(defun alloc-scan-file (file)
  "Scan FILE for allocations using minibuffer to select dump file."
  (interactive "fFile to scan: ")
  (let ((dump-file (alloc-scan--select-dump-file)))
    (when dump-file
      (with-current-buffer (find-file-noselect file)
        (let ((allocations (alloc-scan--parse-dump-file dump-file)))
          (if allocations
              (progn
                (alloc-scan--highlight-allocations allocations)
                (switch-to-buffer (current-buffer))
                (message "Found %d allocations" (length allocations)))
            (message "No allocations found in %s" dump-file)))))))

;;;###autoload
(defun alloc-scan-clear ()
  "Clear all allocation highlights in the current buffer."
  (interactive)
  (alloc-scan--clear-overlays)
  (message "Cleared allocation highlights"))

(provide 'alloc-scan)

;;; alloc-scan.el ends here
